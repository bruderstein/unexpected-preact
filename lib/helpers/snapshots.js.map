{"version":3,"sources":["../../src/helpers/snapshots.js"],"names":["FUNCTION_ID","FUNC_ARGS_REGEX","getFunctionArgs","func","match","exec","toString","split","map","arg","trim","join","writerOptions","handlers","functionDefinition","$functype","name","args","JSON","stringify","UnexpectedSnapshotState","snapshotState","files","_files","testPath","testName","expect","snapshot","snapshotPath","getSnapshotPath","content","contentOutput","Object","keys","reduce","agg","testKey","output","clone","annotationBlock","append","inspect","rawAdapter","deserialize","testCounter","uncheckedKeys","Set","allTests","failedTests","count","keyName","delete","tree","dir","dirname","exists","statSync","isDirectory","e","sync","fileContent","display","test","writeFileSync","add","testPathParsed","parse","base","format","convertToString","concatTextContent","compareSnapshot","flags","subjectAdapter","subjectRenderer","subjectOutput","state","getState","unexpectedSnapshot","getSnapshot","currentTestName","saveSnapshot","serialize","added","withError","satisfy","matched","err","markTestAsFailed","update","updated","unmatched","fail","injectStateHooks","originalRemoveUncheckedKeys","removeUncheckedKeys","isDirty","size","forEach","key","has","length","isFile","unlinkSync","call"],"mappings":"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","file":"snapshots.js","sourcesContent":["import fs from 'fs'\nimport matchers from 'jest-matchers';\nimport jsWriter from 'js-writer';\nimport mkdirp from 'mkdirp';\nimport path from 'path';\nimport RawAdapter from 'unexpected-htmllike-raw-adapter';\nimport { loadSnapshot } from './snapshotLoader';\n\n\n// Serializable \"unique\" ID\nconst FUNCTION_ID = \"$FUNC$bc*(!CDKRRz195123$\";\nconst FUNC_ARGS_REGEX = /function [^(]*\\(([^)]*)\\)/;\n\nfunction getFunctionArgs(func) {\n  const match = FUNC_ARGS_REGEX.exec(func.toString());\n  if (match) {\n    return match[1].split(',').map(arg => arg.trim()).join(', ');\n  }\n  return '';\n}\n\nconst writerOptions = {\n  handlers: {\n    'function': function (func) {\n      const functionDefinition = {\n        $functype: FUNCTION_ID,\n        name: func.name || '',\n        args: getFunctionArgs(func)\n      };\n      return JSON.stringify(functionDefinition)\n    }\n  }\n};\n\nclass UnexpectedSnapshotState {\n  \n  constructor(snapshotState) {\n    const files = {};\n    this._files = files;\n    \n  }\n  \n  getSnapshot(testPath, testName, expect) {\n    let snapshot = this._files[testPath];\n    if (!snapshot) {\n      const snapshotPath = getSnapshotPath(testPath);\n      let content = loadSnapshot(snapshotPath);\n      let contentOutput = {};\n      if (content) {\n        Object.keys(content).reduce((agg, testKey) => {\n          agg[testKey] = expect.output.clone().annotationBlock(function () {\n            this.append(expect.inspect(rawAdapter.deserialize(content[testKey])));\n          }).toString();\n          return agg;\n        }, contentOutput)\n      }\n      \n      snapshot = this._files[testPath] = {\n        testCounter: {},\n        uncheckedKeys: (content && new Set(Object.keys(content))) || new Set(),\n        allTests: content || {},\n        contentOutput: contentOutput,\n        failedTests: new Set()\n      }\n    }\n    const count = (snapshot.testCounter[testName] || 0) + 1;\n    snapshot.testCounter[testName] = count;\n    \n    const keyName = testName + ' ' + count;\n    snapshot.uncheckedKeys.delete(keyName);\n    return snapshot.allTests[keyName] || null;\n  }\n  \n  saveSnapshot(testPath, testName, tree, expect) {\n    \n    const snapshotPath = getSnapshotPath(testPath);\n    const snapshot = this._files[testPath];\n    \n    // If we've been passed a new tree, update the current snapshot\n    // Otherwise, we're just saving the file\n    if (tree) {\n      const count = snapshot.testCounter[testName] || 1;\n  \n      snapshot.allTests[testName + ' ' + count] = tree;\n      snapshot.contentOutput[testName + ' ' + count] = expect.output.clone().annotationBlock(function () {\n        this.append(expect.inspect(tree));\n      }).toString();\n    }\n    const dir = path.dirname(snapshotPath);\n    let exists;\n    try {\n      exists = fs.statSync(dir).isDirectory();\n    } catch (e) {\n      exists = false;\n    }\n    if (!exists) {\n      mkdirp.sync(dir);\n    }\n    const fileContent = Object.keys(snapshot.allTests).map(test => {\n      const display = snapshot.contentOutput[test] || '// Display unavailable (this is probably a bug in unexpected-react, please report it!)';\n      return `/////////////////// ${test} ///////////////////\\n\\n${display}\\n\\nexports[\\`${test}\\`] = ${jsWriter(snapshot.allTests[test], writerOptions)};\\n// ===========================================================================\\n`;\n    }).join('\\n\\n');\n    fs.writeFileSync(snapshotPath, fileContent);\n  }\n  \n  markTestAsFailed(testPath, testName) {\n    const snapshot = this._files[testPath];\n    snapshot.failedTests.add(testName);\n  }\n}\n\nfunction getSnapshotPath(testPath) {\n  const testPathParsed = path.parse(testPath);\n  testPathParsed.dir = path.join(testPathParsed.dir, '__snapshots__');\n  testPathParsed.base = testPathParsed.name + '.unexpected-snap';\n  \n  return path.format(testPathParsed);\n}\n\nconst rawAdapter = new RawAdapter({ convertToString: true, concatTextContent: true });\n\nfunction compareSnapshot(expect, flags, subjectAdapter, subjectRenderer, subjectOutput) {\n  \n  const state = matchers.getState();\n  \n  if (!state.unexpectedSnapshot) {\n    state.unexpectedSnapshot = new UnexpectedSnapshotState(state.snapshotState);\n  }\n\n  const snapshot = state.unexpectedSnapshot.getSnapshot(state.testPath, state.currentTestName, expect);\n  if (snapshot === null) {\n    // Write and save\n    state.unexpectedSnapshot.saveSnapshot(state.testPath, state.currentTestName, rawAdapter.serialize(subjectAdapter, subjectOutput), expect);\n    state.snapshotState.added++;\n  } else {\n    expect.withError(() => {\n      if (flags.satisfy) {\n        expect(subjectRenderer, 'to have rendered', rawAdapter.deserialize(snapshot));\n      } else {\n        expect(subjectRenderer, 'to have rendered with all children with all wrappers with all classes with all attributes', rawAdapter.deserialize(snapshot));\n      }\n      state.snapshotState.matched = (state.snapshotState.matched || 0) + 1;\n    }, function (err) {\n      state.unexpectedSnapshot.markTestAsFailed(state.testPath, state.currentTestName);\n      if (state.snapshotState.update === true) {\n        state.snapshotState.updated++;\n        state.unexpectedSnapshot.saveSnapshot(state.testPath, state.currentTestName, rawAdapter.serialize(subjectAdapter, subjectOutput), expect);\n      } else {\n        state.snapshotState.unmatched++;\n        expect.fail(err);\n      }\n    });\n  }\n}\n\nfunction injectStateHooks() {\n  const state = matchers.getState();\n  const snapshotState = state && state.snapshotState;\n  if (snapshotState) {\n    const originalRemoveUncheckedKeys = snapshotState.removeUncheckedKeys;\n    \n    snapshotState.removeUncheckedKeys = function () {\n      const state = matchers.getState();\n      let isDirty = false;\n      const snapshot = state.unexpectedSnapshot && state.unexpectedSnapshot._files[state.testPath];\n      if (snapshot && snapshot.uncheckedKeys.size) {\n        snapshot.uncheckedKeys.forEach(key => {\n          const testName = /(.*)\\s[0-9]+$/.exec(key)[1];\n          \n          if (!snapshot.failedTests.has(testName)) {\n            isDirty = true;\n            delete snapshot.allTests[key]\n          }\n        });\n      }\n      \n      if (!snapshot || Object.keys(snapshot.allTests).length === 0) {\n        const snapshotPath = getSnapshotPath(state.testPath);\n        try {\n          if (fs.statSync(snapshotPath).isFile()) {\n            fs.unlinkSync(getSnapshotPath(state.testPath));\n          }\n        } catch (e) {\n          // We're ignoring file-not-found exceptions, and errors deleting\n        }\n        \n        if (state.unexpectedSnapshot) {\n          delete state.unexpectedSnapshot._files[state.testPath];\n        }\n      } else if (isDirty) {\n        state.unexpectedSnapshot.saveSnapshot(state.testPath, state.currentTestName);\n      }\n      originalRemoveUncheckedKeys.call(snapshotState);\n    };\n  }\n}\n\n// When this module is required, Jest is already started, and the hooks can be added\ninjectStateHooks();\n\nexport {\n  compareSnapshot,\n  injectStateHooks, // This is exported for testing purposes, and is not normally needed\n  FUNCTION_ID,\n  writerOptions,\n  getFunctionArgs\n}\n"]}